# Kubernetes Wordsmith Demo

Wordsmith is the demo project shown at DockerCon EU 2017, where Docker announced that support for Kubernetes was coming to the Docker platform.

The demo app runs across three containers:

- [db](db/Dockerfile) - a Postgres database which stores words

- [api](api/Dockerfile) - a Java REST API which serves words read from the database

- [web](web/Dockerfile) - a Go web application which calls the API and builds words into sentences:

![The Wordsmith app running in Kubernetes on Docker for Mac](img/dockercon_EU_17.jpg)

## Build

The only requirement to build and run the app from source is Docker. Clone this repo and use Docker Compose to build all the images:

```
git clone https://github.com/jeromebaude/k8s-wordsmith-demo
cd k8s-wordsmith-demo
git checkout update/container_to_kube
docker-compose build
```

Once your images are built, you can push them to your own repository (DTR)

```
docker login
docker push jeromebaude/k8s-wordsmith*
```


## Deploy as a Docker Stack

The latest version of [Docker for Mac](https://www.docker.com/docker-mac) has Kubernetes built-in.

Docker lets you use the simple [Docker Compose](https://docs.docker.com/compose/) file format to deploy complex applications to Kubernetes. You can deploy the wordsmith app to the local Kubernetes cluster using [docker-compose.yml](docker-compose.yml).

First use `docker version` to check whether Docker is running with Kubernetes or Docker Swarm as the orchestrator - Docker for Mac supports both orchestrators **at the same time**:

```
docker version -f '{{ .Client.Orchestrator }}'
```

> You can switch orchestrators with the `DOCKER_ORCHESTRATOR` environment variable, setting it to `kubernetes` or `swarm`.

Deploy the app to Kubernetes as a stack using the [compose file](docker-compose.yml):

```
export DOCKER_ORCHESTRATOR=kubernetes
docker stack deploy wordsmith -c docker-compose.yml
```

Docker for Mac includes the [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/) command line, so you can work directly with the Kube cluster. Check the services are up, and you should see output like this:

```
$ kubectl get svc
NAME         TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
db           ClusterIP      None             <none>        55555/TCP        2m
kubernetes   ClusterIP      10.96.0.1        <none>        443/TCP          38d
web          LoadBalancer   10.107.215.211   <pending>     8080:30220/TCP   2m
api          ClusterIP      None             <none>        55555/TCP        2m
```

Check the pods are running, and you should see one pod each for the database and web components, and five pods for the words API - which is specified as the replica count in the compose file:

```
$ kubectl get pods
NAME                   READY     STATUS    RESTARTS   AGE
db-8678676c79-h2d99    1/1       Running   0          1m
web-5d6bfbbd8b-6zbl8   1/1       Running   0          1m
api-858f6678-6c8kk   1/1       Running   0          1m
api-858f6678-7bqbv   1/1       Running   0          1m
api-858f6678-fjdws   1/1       Running   0          1m
api-858f6678-rrr8c   1/1       Running   0          1m
api-858f6678-x9zqh   1/1       Running   0          1m
```

Then browse to http://localhost:8080 to see the site. Each time you refresh the page, you'll see a different sentence generated by the API calls.

When you are done, you can shutdown

## Deploy Using a Kubernetes Manifest

You can deploy the same app to Kubernetes using the [Kubernetes manifest](kube-deployment.yml). That describes the same application in terms of Kubernetes deployments, services and pod specifications.

First remove the Kubernetes stack:

```
docker stack rm wordsmith
```

> Alternatively You can leave the Docker stack deployment running, and create a second deployment in a new Kubernetes namespace.

Now apply the manifest using `kubectl`:

```
$ cd kube
$ kubectl apply -f .
deployment "api" created
service "api" created
deployment "db" created
service "db" created
deployment "web" created
service "web" created
```

This will create everything needed using one file per Service, ReplicaSet and Deployment.

```
$ kubectl get deploy,service,replicaset
NAME         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
deploy/api   5         5         5            5           2m
deploy/db    1         1         1            1           2m
deploy/web   1         1         1            1           2m

NAME             TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
svc/api          ClusterIP      None             <none>        8080/TCP         2m
svc/db           ClusterIP      None             <none>        5432/TCP         2m
svc/kubernetes   ClusterIP      10.96.0.1        <none>        443/TCP          1d
svc/web          LoadBalancer   10.109.140.172   <pending>     8081:32724/TCP   2m

NAME                DESIRED   CURRENT   READY     AGE
rs/api-5f75c58954   5         5         5         2m
rs/db-675d6c6dd8    1         1         1         2m
rs/web-65b986cd86   1         1         1         2m
```


Now browse to http://localhost:8081 and you will see the same site.

To remove the service.

```
$ kubectl delete -f .
deployment "api" deleted
service "api" deleted
deployment "db" deleted
service "db" deleted
deployment "web" deleted
service "web" deleted
```
